# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GPVContourDialog
                                 A QGIS plugin
 Make contour  from GPV
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-12-29
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Naoya Nishibayashi
        email                : naoya.bayashi@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import datetime

import processing

from PyQt5.Qt import *
from qgis.utils import iface
from qgis.core import *
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.gui import (QgsMapLayerComboBox,
                      QgsFieldComboBox)
from qgis.core import QgsMapLayerProxyModel

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'gpv_contour_dialog_base.ui'))


class GPVContourDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(GPVContourDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.mMapLayerComboBox_input.setFilters(QgsMapLayerProxyModel.RasterLayer)

        self.mMapLayerComboBox_input.setLayer(iface.activeLayer())
        #layer = self.mMapLayerComboBox_input.currentLayer()
        self.set_element

        # レイヤが変更されたらフィールドも変更
        self.mMapLayerComboBox_input.layerChanged.connect(
            self.set_element)

        #実行ボタン
        self.button_box.accepted.connect(self.run)
        self.button_box.rejected.connect(self.dlg_close)

    # レイヤが変更された時のフィールド取得
    def set_element(self):
        layer = self.mMapLayerComboBox_input.currentLayer()
        if layer.name().split('_')[5] == 'MSM':
            if layer.name().split('_')[8] =='Lsurf':
                self.comboBox.clear()
                self.comboBox.addItems(['海面更正気圧', '地上気圧','気温'])
            elif layer.name().split('_')[8] =='L-pall':
                self.comboBox.clear()
                self.comboBox.addItems(['1000hPa気圧面高度', '975hPa気圧面高度','950hPa気圧面高度','925hPa気圧面高度','900hPa気圧面高度','850hPa気圧面高度','800hPa気圧面高度','700hPa気圧面高度','600hPa気圧面高度','500hPa気圧面高度','400hPa気圧面高度','300hPa気圧面高度','250hPa気圧面高度','200hPa気圧面高度','150hPa気圧面高度','100hPa気圧面高度'])
                self.comboBox.addItems(['1000hPa気圧面気温', '975hPa気圧面気温','950hPa気圧面気温','925hPa気圧面気温','900hPa気圧面気温','850hPa気圧面気温','800hPa気圧面気温','700hPa気圧面気温','600hPa気圧面気温','500hPa気圧面気温','400hPa気圧面気温','300hPa気圧面気温','250hPa気圧面気温','200hPa気圧面気温','150hPa気圧面気温','100hPa気圧面気温'])
        else:
            self.comboBox.clear()
            self.comboBox.addItem('メソモデル(MSM)のデータを選択してください')


    def dlg_close(self):
        self.close()

    def run(self):
        layer = self.mMapLayerComboBox_input.currentLayer()
        try:
            if layer.name().split('_')[5] != 'MSM':
                raise ValueError()
        except ValueError as e:
            QMessageBox.information(None, u'入力レイヤエラー', '現在はメソモデル(MSM)しか対応してません。')
            return

        element = self.comboBox.currentText()


        date = layer.name().split('_')[4]
        model = layer.name().split('_')[5]

        # forcast step
        if model == 'MSM':
            height = layer.name().split('_')[8]
            if height == 'Lsurf':
                forcastStep = 1
                elementDic = {'海面更正気圧':1,'地上気圧':2,'気温':5}
            else:
                forcastStep = 3
                if element[-2:] == '高度':
                    elementDic = {'1000hPa気圧面高度':1, '975hPa気圧面高度':7,'950hPa気圧面高度':13,'925hPa気圧面高度':19,'900hPa気圧面高度':25,'850hPa気圧面高度':31,'800hPa気圧面高度':37,'700hPa気圧面高度':43,'600hPa気圧面高度':49,'500hPa気圧面高度':55,'400hPa気圧面高度':61,'300hPa気圧面高度':67,'250hPa気圧面高度':73,'200hPa気圧面高度':78,'150hPa気圧面高度':83,'100hPa気圧面高度':88}
                elif element[-2:] =='気温':
                    elementDic = {'1000hPa気圧面気温':4, '975hPa気圧面気温':10,'950hPa気圧面気温':16,'925hPa気圧面気温':22,'900hPa気圧面気温':28,'850hPa気圧面気温':34,'800hPa気圧面気温':40,'700hPa気圧面気温':46,'600hPa気圧面気温':52,'500hPa気圧面気温':58,'400hPa気圧面気温':64,'300hPa気圧面気温':70,'250hPa気圧面気温':76,'200hPa気圧面気温':81,'150hPa気圧面気温':86,'100hPa気圧面気温':91}
            
    

            FH = int(layer.name().split('_')[9][2:4])
        
        # interval
        if element == '海面更正気圧':
            interval = 100
        elif element == '地上気圧':
            interval = 1000
        elif element[-2:] == '高度':
            interval = 60
        elif element[-2:] == '気温':
            interval = 3

        bands = self.get_bands(layer,elementDic,FH,element)
        
        self.make_contour(layer,interval,element,date,FH,bands,forcastStep)
        self.close()



    def get_bands(self,layer,elementDic,FH,element):
        bandOffset = elementDic[element]
        if layer.name().split('_')[8] == 'Lsurf':
            if FH == 0:
                bands = [0+bandOffset, 10+bandOffset]
                for band in range(22+bandOffset, layer.bandCount(), 12):
                    bands.append(band)
            else:
                bands =[]
                for band in range(0+bandOffset, layer.bandCount(), 12):
                    bands.append(band)
        else:
            bands = []
            for band in range(0+bandOffset, layer.bandCount(), 92):
                bands.append(band)

        return bands
    
    def setting_label(self,element):
        if element[-2:] == '気圧':
            labelField = '"Contour"/100'
            labelExpression = '"Contour" %2000=0'
        elif element[-2:] == '高度':
            labelField = '"Contour"'
            labelExpression = '"Contour" %120=0'
        elif element[-2:] == '気温':
            labelField = '"Contour"'
            labelExpression = '"Contour" %6=0'

        return (labelField,labelExpression)


    def make_contour(self,layer,interval,element,date,FH,bands,forcastStep):
        # identify date
        YYYY = int(date[:4])
        MM = int(date[4:6])
        DD = int(date[6:8])
        hh = int(date[8:10])
        mm = int(date[10:12])
        ss = int(date[12:14])
        startTime = datetime.datetime(YYYY, MM, DD, hh, mm, ss)

        labelSetting = self.setting_label(element)

        #Contour
        for band in bands:
            forcastTime = startTime + datetime.timedelta(hours=FH)
            contour = processing.run("gdal:contour", {'INPUT': layer, 'BAND': band, 'INTERVAL': interval, 'FIELD_NAME': 'Contour',
                                                    'CREATE_3D': False, 'IGNORE_NODATA': False, 'NODATA': None, 'OFFSET': 0, 'EXTRA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
            name = element + 'contour_' + str(startTime.year) + '/' + str('{0:02d}'.format(startTime.month)) + '/' + str('{0:02d}'.format(startTime.day)) + '_' + str('{0:02d}'.format(startTime.hour)) + str('{0:02d}'.format(startTime.minute)) + str('{0:02d}'.format(startTime.second)) + '(' + str(
                FH) + ')' + '-' + str(forcastTime.year) + '/' + str('{0:02d}'.format(forcastTime.month)) + '/' + str('{0:02d}'.format(forcastTime.day)) + '_' + str('{0:02d}'.format(forcastTime.hour)) + str('{0:02d}'.format(forcastTime.minute)) + str('{0:02d}'.format(forcastTime.second))
            vlayer = iface.addVectorLayer(contour['OUTPUT'], name, 'ogr')
            # set temporal properties
            mode = QgsVectorLayerTemporalProperties.ModeFixedTemporalRange
            tprops = vlayer.temporalProperties()
            tprops.setMode(mode)
            tprops.setFixedTemporalRange(QgsDateTimeRange(QDateTime(QDate(forcastTime.year, forcastTime.month, forcastTime.day), QTime(
                forcastTime.hour, 0, 0, 0), Qt.UTC), QDateTime(QDate(forcastTime.year, forcastTime.month, forcastTime.day), QTime(forcastTime.hour, 0, 0, 0), Qt.UTC)))
            tprops.setIsActive(True)
            # set labeling
            pal_layer = QgsPalLayerSettings()
            pal_layer.isExpression = True
            pal_layer.fieldName = labelSetting[0]
            pal_layer.enabled = True
            pal_layer.placement = QgsPalLayerSettings.Line
            # Create and append a new rule
            root = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())
            rule = QgsRuleBasedLabeling.Rule(pal_layer)
            rule.setDescription('only step 2000')
            rule.setFilterExpression(labelSetting[1])
            root.appendChild(rule)
            # Apply label configuration
            vlayer.setLabelsEnabled(True)
            rules = QgsRuleBasedLabeling(root)
            vlayer.setLabeling(rules)
            vlayer.triggerRepaint()
            # set symbol
            single_symbol_renderer = vlayer.renderer()
            symbol = single_symbol_renderer.symbol()
            # Set stroke colour
            symbol.setColor(QColor.fromRgb(100, 100, 100))
            # Refresh
            vlayer.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology(vlayer.id())
            # next FH
            FH += forcastStep
